// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: feeabstraction/feeabs/v1beta1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../../cosmos/base/v1beta1/coin.js";
import { Params } from "./params.js";
import { HostChainFeeAbsConfig } from "./proposal.js";

/** MsgFundFeeAbsModuleAccount */
export interface MsgFundFeeAbsModuleAccount {
  /** sender is the that actor that signed the messages */
  sender: string;
  amount: Coin[];
}

/** MsgFundFeeAbsModuleAccountResponse */
export interface MsgFundFeeAbsModuleAccountResponse {
}

/** MsgSendQueryIbcDenomTWAP */
export interface MsgSendQueryIbcDenomTWAP {
  /** Sender is the that actor that signed the messages */
  sender: string;
}

/** MsgSendQueryIbcDenomTWAPResponse */
export interface MsgSendQueryIbcDenomTWAPResponse {
}

/** MsgSwapCrossChain */
export interface MsgSwapCrossChain {
  /** Sender is the that actor that signed the messages */
  sender: string;
  ibcDenom: string;
}

/** MsgSwapCrossChainResponse */
export interface MsgSwapCrossChainResponse {
}

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /** authority is the address of the governance account. */
  authority: string;
  /**
   * params defines the x/feeabs parameters to update.
   *
   * NOTE: All parameters must be supplied.
   */
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

/** MsgAddHostZone is the Msg/AddHostZone request type. */
export interface MsgAddHostZone {
  /** authority is the address of the governance account. */
  authority: string;
  /** the host chain config */
  hostChainConfig: HostChainFeeAbsConfig | undefined;
}

/** MsgAddHostZoneResponse */
export interface MsgAddHostZoneResponse {
}

/** MsgUpdateHostZone is the Msg/UpdateHostZone request type. */
export interface MsgUpdateHostZone {
  /** authority is the address of the governance account. */
  authority: string;
  /** the host chain config */
  hostChainConfig: HostChainFeeAbsConfig | undefined;
}

/** MsgUpdateHostZoneResponse */
export interface MsgUpdateHostZoneResponse {
}

/** MsgRemoveHostZone is the Msg/RemoveHostZone request type. */
export interface MsgRemoveHostZone {
  /** authority is the address of the governance account. */
  authority: string;
  ibcDenom: string;
}

/** MsgRemoveHostZoneResponse */
export interface MsgRemoveHostZoneResponse {
}

function createBaseMsgFundFeeAbsModuleAccount(): MsgFundFeeAbsModuleAccount {
  return { sender: "", amount: [] };
}

export const MsgFundFeeAbsModuleAccount: MessageFns<MsgFundFeeAbsModuleAccount> = {
  encode(message: MsgFundFeeAbsModuleAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFundFeeAbsModuleAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFundFeeAbsModuleAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFundFeeAbsModuleAccount {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgFundFeeAbsModuleAccount): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFundFeeAbsModuleAccount>, I>>(base?: I): MsgFundFeeAbsModuleAccount {
    return MsgFundFeeAbsModuleAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFundFeeAbsModuleAccount>, I>>(object: I): MsgFundFeeAbsModuleAccount {
    const message = createBaseMsgFundFeeAbsModuleAccount();
    message.sender = object.sender ?? "";
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgFundFeeAbsModuleAccountResponse(): MsgFundFeeAbsModuleAccountResponse {
  return {};
}

export const MsgFundFeeAbsModuleAccountResponse: MessageFns<MsgFundFeeAbsModuleAccountResponse> = {
  encode(_: MsgFundFeeAbsModuleAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFundFeeAbsModuleAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFundFeeAbsModuleAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFundFeeAbsModuleAccountResponse {
    return {};
  },

  toJSON(_: MsgFundFeeAbsModuleAccountResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFundFeeAbsModuleAccountResponse>, I>>(
    base?: I,
  ): MsgFundFeeAbsModuleAccountResponse {
    return MsgFundFeeAbsModuleAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFundFeeAbsModuleAccountResponse>, I>>(
    _: I,
  ): MsgFundFeeAbsModuleAccountResponse {
    const message = createBaseMsgFundFeeAbsModuleAccountResponse();
    return message;
  },
};

function createBaseMsgSendQueryIbcDenomTWAP(): MsgSendQueryIbcDenomTWAP {
  return { sender: "" };
}

export const MsgSendQueryIbcDenomTWAP: MessageFns<MsgSendQueryIbcDenomTWAP> = {
  encode(message: MsgSendQueryIbcDenomTWAP, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSendQueryIbcDenomTWAP {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendQueryIbcDenomTWAP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSendQueryIbcDenomTWAP {
    return { sender: isSet(object.sender) ? globalThis.String(object.sender) : "" };
  },

  toJSON(message: MsgSendQueryIbcDenomTWAP): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSendQueryIbcDenomTWAP>, I>>(base?: I): MsgSendQueryIbcDenomTWAP {
    return MsgSendQueryIbcDenomTWAP.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSendQueryIbcDenomTWAP>, I>>(object: I): MsgSendQueryIbcDenomTWAP {
    const message = createBaseMsgSendQueryIbcDenomTWAP();
    message.sender = object.sender ?? "";
    return message;
  },
};

function createBaseMsgSendQueryIbcDenomTWAPResponse(): MsgSendQueryIbcDenomTWAPResponse {
  return {};
}

export const MsgSendQueryIbcDenomTWAPResponse: MessageFns<MsgSendQueryIbcDenomTWAPResponse> = {
  encode(_: MsgSendQueryIbcDenomTWAPResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSendQueryIbcDenomTWAPResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendQueryIbcDenomTWAPResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSendQueryIbcDenomTWAPResponse {
    return {};
  },

  toJSON(_: MsgSendQueryIbcDenomTWAPResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSendQueryIbcDenomTWAPResponse>, I>>(
    base?: I,
  ): MsgSendQueryIbcDenomTWAPResponse {
    return MsgSendQueryIbcDenomTWAPResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSendQueryIbcDenomTWAPResponse>, I>>(
    _: I,
  ): MsgSendQueryIbcDenomTWAPResponse {
    const message = createBaseMsgSendQueryIbcDenomTWAPResponse();
    return message;
  },
};

function createBaseMsgSwapCrossChain(): MsgSwapCrossChain {
  return { sender: "", ibcDenom: "" };
}

export const MsgSwapCrossChain: MessageFns<MsgSwapCrossChain> = {
  encode(message: MsgSwapCrossChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.ibcDenom !== "") {
      writer.uint32(18).string(message.ibcDenom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSwapCrossChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSwapCrossChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ibcDenom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSwapCrossChain {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      ibcDenom: isSet(object.ibcDenom) ? globalThis.String(object.ibcDenom) : "",
    };
  },

  toJSON(message: MsgSwapCrossChain): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.ibcDenom !== "") {
      obj.ibcDenom = message.ibcDenom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSwapCrossChain>, I>>(base?: I): MsgSwapCrossChain {
    return MsgSwapCrossChain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSwapCrossChain>, I>>(object: I): MsgSwapCrossChain {
    const message = createBaseMsgSwapCrossChain();
    message.sender = object.sender ?? "";
    message.ibcDenom = object.ibcDenom ?? "";
    return message;
  },
};

function createBaseMsgSwapCrossChainResponse(): MsgSwapCrossChainResponse {
  return {};
}

export const MsgSwapCrossChainResponse: MessageFns<MsgSwapCrossChainResponse> = {
  encode(_: MsgSwapCrossChainResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSwapCrossChainResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSwapCrossChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSwapCrossChainResponse {
    return {};
  },

  toJSON(_: MsgSwapCrossChainResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSwapCrossChainResponse>, I>>(base?: I): MsgSwapCrossChainResponse {
    return MsgSwapCrossChainResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSwapCrossChainResponse>, I>>(_: I): MsgSwapCrossChainResponse {
    const message = createBaseMsgSwapCrossChainResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgAddHostZone(): MsgAddHostZone {
  return { authority: "", hostChainConfig: undefined };
}

export const MsgAddHostZone: MessageFns<MsgAddHostZone> = {
  encode(message: MsgAddHostZone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.hostChainConfig !== undefined) {
      HostChainFeeAbsConfig.encode(message.hostChainConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddHostZone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddHostZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostChainConfig = HostChainFeeAbsConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddHostZone {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      hostChainConfig: isSet(object.hostChainConfig)
        ? HostChainFeeAbsConfig.fromJSON(object.hostChainConfig)
        : undefined,
    };
  },

  toJSON(message: MsgAddHostZone): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.hostChainConfig !== undefined) {
      obj.hostChainConfig = HostChainFeeAbsConfig.toJSON(message.hostChainConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddHostZone>, I>>(base?: I): MsgAddHostZone {
    return MsgAddHostZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddHostZone>, I>>(object: I): MsgAddHostZone {
    const message = createBaseMsgAddHostZone();
    message.authority = object.authority ?? "";
    message.hostChainConfig = (object.hostChainConfig !== undefined && object.hostChainConfig !== null)
      ? HostChainFeeAbsConfig.fromPartial(object.hostChainConfig)
      : undefined;
    return message;
  },
};

function createBaseMsgAddHostZoneResponse(): MsgAddHostZoneResponse {
  return {};
}

export const MsgAddHostZoneResponse: MessageFns<MsgAddHostZoneResponse> = {
  encode(_: MsgAddHostZoneResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddHostZoneResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddHostZoneResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddHostZoneResponse {
    return {};
  },

  toJSON(_: MsgAddHostZoneResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddHostZoneResponse>, I>>(base?: I): MsgAddHostZoneResponse {
    return MsgAddHostZoneResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddHostZoneResponse>, I>>(_: I): MsgAddHostZoneResponse {
    const message = createBaseMsgAddHostZoneResponse();
    return message;
  },
};

function createBaseMsgUpdateHostZone(): MsgUpdateHostZone {
  return { authority: "", hostChainConfig: undefined };
}

export const MsgUpdateHostZone: MessageFns<MsgUpdateHostZone> = {
  encode(message: MsgUpdateHostZone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.hostChainConfig !== undefined) {
      HostChainFeeAbsConfig.encode(message.hostChainConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateHostZone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateHostZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hostChainConfig = HostChainFeeAbsConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateHostZone {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      hostChainConfig: isSet(object.hostChainConfig)
        ? HostChainFeeAbsConfig.fromJSON(object.hostChainConfig)
        : undefined,
    };
  },

  toJSON(message: MsgUpdateHostZone): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.hostChainConfig !== undefined) {
      obj.hostChainConfig = HostChainFeeAbsConfig.toJSON(message.hostChainConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateHostZone>, I>>(base?: I): MsgUpdateHostZone {
    return MsgUpdateHostZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateHostZone>, I>>(object: I): MsgUpdateHostZone {
    const message = createBaseMsgUpdateHostZone();
    message.authority = object.authority ?? "";
    message.hostChainConfig = (object.hostChainConfig !== undefined && object.hostChainConfig !== null)
      ? HostChainFeeAbsConfig.fromPartial(object.hostChainConfig)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateHostZoneResponse(): MsgUpdateHostZoneResponse {
  return {};
}

export const MsgUpdateHostZoneResponse: MessageFns<MsgUpdateHostZoneResponse> = {
  encode(_: MsgUpdateHostZoneResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateHostZoneResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateHostZoneResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateHostZoneResponse {
    return {};
  },

  toJSON(_: MsgUpdateHostZoneResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateHostZoneResponse>, I>>(base?: I): MsgUpdateHostZoneResponse {
    return MsgUpdateHostZoneResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateHostZoneResponse>, I>>(_: I): MsgUpdateHostZoneResponse {
    const message = createBaseMsgUpdateHostZoneResponse();
    return message;
  },
};

function createBaseMsgRemoveHostZone(): MsgRemoveHostZone {
  return { authority: "", ibcDenom: "" };
}

export const MsgRemoveHostZone: MessageFns<MsgRemoveHostZone> = {
  encode(message: MsgRemoveHostZone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.ibcDenom !== "") {
      writer.uint32(18).string(message.ibcDenom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveHostZone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveHostZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ibcDenom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveHostZone {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      ibcDenom: isSet(object.ibcDenom) ? globalThis.String(object.ibcDenom) : "",
    };
  },

  toJSON(message: MsgRemoveHostZone): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.ibcDenom !== "") {
      obj.ibcDenom = message.ibcDenom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRemoveHostZone>, I>>(base?: I): MsgRemoveHostZone {
    return MsgRemoveHostZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRemoveHostZone>, I>>(object: I): MsgRemoveHostZone {
    const message = createBaseMsgRemoveHostZone();
    message.authority = object.authority ?? "";
    message.ibcDenom = object.ibcDenom ?? "";
    return message;
  },
};

function createBaseMsgRemoveHostZoneResponse(): MsgRemoveHostZoneResponse {
  return {};
}

export const MsgRemoveHostZoneResponse: MessageFns<MsgRemoveHostZoneResponse> = {
  encode(_: MsgRemoveHostZoneResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveHostZoneResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveHostZoneResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveHostZoneResponse {
    return {};
  },

  toJSON(_: MsgRemoveHostZoneResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRemoveHostZoneResponse>, I>>(base?: I): MsgRemoveHostZoneResponse {
    return MsgRemoveHostZoneResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRemoveHostZoneResponse>, I>>(_: I): MsgRemoveHostZoneResponse {
    const message = createBaseMsgRemoveHostZoneResponse();
    return message;
  },
};

/** Msg defines the wasm Msg service. */
export interface Msg {
  /** SendQueryIbcDenomTWAP sends a twap query to osmosis */
  SendQueryIbcDenomTWAP(request: MsgSendQueryIbcDenomTWAP): Promise<MsgSendQueryIbcDenomTWAPResponse>;
  /** SwapCrossChain submits a swap cross chain request. */
  SwapCrossChain(request: MsgSwapCrossChain): Promise<MsgSwapCrossChainResponse>;
  /** FundFeeAbsModuleAccount funds to feeabs module account. */
  FundFeeAbsModuleAccount(request: MsgFundFeeAbsModuleAccount): Promise<MsgFundFeeAbsModuleAccountResponse>;
  /**
   * UpdateParams defines a governance operation for updating the x/feeabs
   * module parameters. The authority is defined in the keeper.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  AddHostZone(request: MsgAddHostZone): Promise<MsgAddHostZoneResponse>;
  UpdateHostZone(request: MsgUpdateHostZone): Promise<MsgUpdateHostZoneResponse>;
  RemoveHostZone(request: MsgRemoveHostZone): Promise<MsgRemoveHostZoneResponse>;
}

export const MsgServiceName = "feeabstraction.feeabs.v1beta1.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.SendQueryIbcDenomTWAP = this.SendQueryIbcDenomTWAP.bind(this);
    this.SwapCrossChain = this.SwapCrossChain.bind(this);
    this.FundFeeAbsModuleAccount = this.FundFeeAbsModuleAccount.bind(this);
    this.UpdateParams = this.UpdateParams.bind(this);
    this.AddHostZone = this.AddHostZone.bind(this);
    this.UpdateHostZone = this.UpdateHostZone.bind(this);
    this.RemoveHostZone = this.RemoveHostZone.bind(this);
  }
  SendQueryIbcDenomTWAP(request: MsgSendQueryIbcDenomTWAP): Promise<MsgSendQueryIbcDenomTWAPResponse> {
    const data = MsgSendQueryIbcDenomTWAP.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendQueryIbcDenomTWAP", data);
    return promise.then((data) => MsgSendQueryIbcDenomTWAPResponse.decode(new BinaryReader(data)));
  }

  SwapCrossChain(request: MsgSwapCrossChain): Promise<MsgSwapCrossChainResponse> {
    const data = MsgSwapCrossChain.encode(request).finish();
    const promise = this.rpc.request(this.service, "SwapCrossChain", data);
    return promise.then((data) => MsgSwapCrossChainResponse.decode(new BinaryReader(data)));
  }

  FundFeeAbsModuleAccount(request: MsgFundFeeAbsModuleAccount): Promise<MsgFundFeeAbsModuleAccountResponse> {
    const data = MsgFundFeeAbsModuleAccount.encode(request).finish();
    const promise = this.rpc.request(this.service, "FundFeeAbsModuleAccount", data);
    return promise.then((data) => MsgFundFeeAbsModuleAccountResponse.decode(new BinaryReader(data)));
  }

  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  AddHostZone(request: MsgAddHostZone): Promise<MsgAddHostZoneResponse> {
    const data = MsgAddHostZone.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddHostZone", data);
    return promise.then((data) => MsgAddHostZoneResponse.decode(new BinaryReader(data)));
  }

  UpdateHostZone(request: MsgUpdateHostZone): Promise<MsgUpdateHostZoneResponse> {
    const data = MsgUpdateHostZone.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateHostZone", data);
    return promise.then((data) => MsgUpdateHostZoneResponse.decode(new BinaryReader(data)));
  }

  RemoveHostZone(request: MsgRemoveHostZone): Promise<MsgRemoveHostZoneResponse> {
    const data = MsgRemoveHostZone.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveHostZone", data);
    return promise.then((data) => MsgRemoveHostZoneResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
