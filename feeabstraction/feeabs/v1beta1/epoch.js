// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: feeabstraction/feeabs/v1beta1/epoch.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../../../google/protobuf/duration.js";
import { Timestamp } from "../../../google/protobuf/timestamp.js";
function createBaseEpochInfo() {
    return {
        identifier: "",
        startTime: undefined,
        duration: undefined,
        currentEpoch: 0n,
        currentEpochStartTime: undefined,
        epochCountingStarted: false,
        currentEpochStartHeight: 0n,
    };
}
export const EpochInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.identifier !== "") {
            writer.uint32(10).string(message.identifier);
        }
        if (message.startTime !== undefined) {
            Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
        }
        if (message.duration !== undefined) {
            Duration.encode(message.duration, writer.uint32(26).fork()).join();
        }
        if (message.currentEpoch !== 0n) {
            if (BigInt.asIntN(64, message.currentEpoch) !== message.currentEpoch) {
                throw new globalThis.Error("value provided for field message.currentEpoch of type int64 too large");
            }
            writer.uint32(32).int64(message.currentEpoch);
        }
        if (message.currentEpochStartTime !== undefined) {
            Timestamp.encode(toTimestamp(message.currentEpochStartTime), writer.uint32(42).fork()).join();
        }
        if (message.epochCountingStarted !== false) {
            writer.uint32(48).bool(message.epochCountingStarted);
        }
        if (message.currentEpochStartHeight !== 0n) {
            if (BigInt.asIntN(64, message.currentEpochStartHeight) !== message.currentEpochStartHeight) {
                throw new globalThis.Error("value provided for field message.currentEpochStartHeight of type int64 too large");
            }
            writer.uint32(64).int64(message.currentEpochStartHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEpochInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.identifier = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.duration = Duration.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.currentEpoch = reader.int64();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.currentEpochStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.epochCountingStarted = reader.bool();
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.currentEpochStartHeight = reader.int64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
            startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
            duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
            currentEpoch: isSet(object.currentEpoch) ? BigInt(object.currentEpoch) : 0n,
            currentEpochStartTime: isSet(object.currentEpochStartTime)
                ? fromJsonTimestamp(object.currentEpochStartTime)
                : undefined,
            epochCountingStarted: isSet(object.epochCountingStarted)
                ? globalThis.Boolean(object.epochCountingStarted)
                : false,
            currentEpochStartHeight: isSet(object.currentEpochStartHeight) ? BigInt(object.currentEpochStartHeight) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.identifier !== "") {
            obj.identifier = message.identifier;
        }
        if (message.startTime !== undefined) {
            obj.startTime = message.startTime.toISOString();
        }
        if (message.duration !== undefined) {
            obj.duration = Duration.toJSON(message.duration);
        }
        if (message.currentEpoch !== 0n) {
            obj.currentEpoch = message.currentEpoch.toString();
        }
        if (message.currentEpochStartTime !== undefined) {
            obj.currentEpochStartTime = message.currentEpochStartTime.toISOString();
        }
        if (message.epochCountingStarted !== false) {
            obj.epochCountingStarted = message.epochCountingStarted;
        }
        if (message.currentEpochStartHeight !== 0n) {
            obj.currentEpochStartHeight = message.currentEpochStartHeight.toString();
        }
        return obj;
    },
    create(base) {
        return EpochInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEpochInfo();
        message.identifier = object.identifier ?? "";
        message.startTime = object.startTime ?? undefined;
        message.duration = (object.duration !== undefined && object.duration !== null)
            ? Duration.fromPartial(object.duration)
            : undefined;
        message.currentEpoch = object.currentEpoch ?? 0n;
        message.currentEpochStartTime = object.currentEpochStartTime ?? undefined;
        message.epochCountingStarted = object.epochCountingStarted ?? false;
        message.currentEpochStartHeight = object.currentEpochStartHeight ?? 0n;
        return message;
    },
};
function createBaseExponentialBackoff() {
    return { jump: 0n, futureEpoch: 0n };
}
export const ExponentialBackoff = {
    encode(message, writer = new BinaryWriter()) {
        if (message.jump !== 0n) {
            if (BigInt.asIntN(64, message.jump) !== message.jump) {
                throw new globalThis.Error("value provided for field message.jump of type int64 too large");
            }
            writer.uint32(8).int64(message.jump);
        }
        if (message.futureEpoch !== 0n) {
            if (BigInt.asIntN(64, message.futureEpoch) !== message.futureEpoch) {
                throw new globalThis.Error("value provided for field message.futureEpoch of type int64 too large");
            }
            writer.uint32(16).int64(message.futureEpoch);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExponentialBackoff();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.jump = reader.int64();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.futureEpoch = reader.int64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            jump: isSet(object.jump) ? BigInt(object.jump) : 0n,
            futureEpoch: isSet(object.futureEpoch) ? BigInt(object.futureEpoch) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.jump !== 0n) {
            obj.jump = message.jump.toString();
        }
        if (message.futureEpoch !== 0n) {
            obj.futureEpoch = message.futureEpoch.toString();
        }
        return obj;
    },
    create(base) {
        return ExponentialBackoff.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExponentialBackoff();
        message.jump = object.jump ?? 0n;
        message.futureEpoch = object.futureEpoch ?? 0n;
        return message;
    },
};
function toTimestamp(date) {
    const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (globalThis.Number(t.seconds.toString()) || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=epoch.js.map